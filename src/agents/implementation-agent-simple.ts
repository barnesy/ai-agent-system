import { BaseAgent, AgentMessage, AgentCapabilities } from './base-agent';
import { getCurrentConfig } from '../config';
import { getTokenTracker } from '../metrics/token-tracker';

interface SimpleCodeGeneration {
  code: string;
  language: string;
  explanation: string;
  fileName?: string;
}

/**
 * Simplified Implementation Agent for Phase 1
 * Focuses on core code generation without complex dependencies
 */
export class ImplementationAgentSimple extends BaseAgent {
  constructor() {
    const capabilities: AgentCapabilities = {
      canHandle: (task: string) => {
        const implementationKeywords = [
          'implement', 'code', 'build', 'create', 'write',
          'fix', 'add', 'update', 'modify'
        ];
        return implementationKeywords.some(keyword => 
          task.toLowerCase().includes(keyword)
        );
      },
      estimateTime: (task: string) => {
        // Simplified estimation for Phase 1
        if (task.includes('feature')) return 30;
        if (task.includes('fix')) return 15;
        return 20;
      },
      dependencies: [] // No dependencies in Phase 1
    };

    super('ImplementationAgent', capabilities);
  }

  async execute(message: AgentMessage): Promise<AgentMessage> {
    const { task, context } = message.payload;
    const startTime = Date.now();
    
    try {
      // Phase 1: Simple code generation
      const implementation = await this.generateSimpleImplementation(task, context);
      
      // Track basic metrics
      const executionTime = Date.now() - startTime;
      
      // Track token usage (simulated for Phase 1)
      const estimatedTokens = this.estimateTokenUsage(task, implementation);
      const tracker = getTokenTracker();
      tracker.trackUsage(this.name, task, estimatedTokens, executionTime);
      
      return {
        from: this.name,
        to: message.from,
        type: 'response',
        payload: {
          task: `Implementation completed: ${task}`,
          context: {
            ...implementation,
            metrics: {
              executionTimeMs: executionTime,
              linesOfCode: implementation.code.split('\n').length,
              phase: getCurrentConfig().phase
            }
          },
          priority: message.payload.priority,
        },
        timestamp: new Date()
      };
    } catch (error) {
      return {
        from: this.name,
        to: message.from,
        type: 'response',
        payload: {
          task: `Implementation failed: ${task}`,
          context: {
            error: error instanceof Error ? error.message : 'Unknown error',
            phase: getCurrentConfig().phase
          },
          priority: message.payload.priority,
        },
        timestamp: new Date()
      };
    }
  }

  private async generateSimpleImplementation(
    task: string, 
    context: any
  ): Promise<SimpleCodeGeneration> {
    // Phase 1: Pattern-based code generation
    
    // Analyze task to determine code type
    const taskLower = task.toLowerCase();
    
    if (taskLower.includes('function') || taskLower.includes('utility')) {
      return this.generateUtilityFunction(task, context);
    } else if (taskLower.includes('class') || taskLower.includes('service')) {
      return this.generateClassCode(task, context);
    } else if (taskLower.includes('test')) {
      return this.generateTestCode(task, context);
    } else if (taskLower.includes('fix')) {
      return this.generateBugFix(task, context);
    } else {
      return this.generateGenericCode(task, context);
    }
  }

  private generateUtilityFunction(task: string, context: any): SimpleCodeGeneration {
    const functionName = context?.functionName || 'processData';
    const code = `/**
 * ${task}
 * Generated by AI Agent System - Phase 1
 */
export function ${functionName}(input: any): any {
  // Validate input
  if (!input) {
    throw new Error('Input is required');
  }

  // Process logic
  const result = {
    processed: true,
    timestamp: Date.now(),
    data: input
  };

  // Apply transformations
  if (typeof input === 'string') {
    result.data = input.trim();
  } else if (Array.isArray(input)) {
    result.data = input.filter(Boolean);
  }

  return result;
}`;

    return {
      code,
      language: 'typescript',
      explanation: `Created utility function '${functionName}' with input validation and basic processing`,
      fileName: `${functionName}.ts`
    };
  }

  private generateClassCode(task: string, context: any): SimpleCodeGeneration {
    const className = context?.className || 'DataService';
    const code = `/**
 * ${task}
 * Generated by AI Agent System - Phase 1
 */
export class ${className} {
  private data: Map<string, any>;

  constructor() {
    this.data = new Map();
  }

  async get(key: string): Promise<any> {
    return this.data.get(key);
  }

  async set(key: string, value: any): Promise<void> {
    this.data.set(key, value);
  }

  async delete(key: string): Promise<boolean> {
    return this.data.delete(key);
  }

  async clear(): Promise<void> {
    this.data.clear();
  }

  getSize(): number {
    return this.data.size;
  }
}`;

    return {
      code,
      language: 'typescript',
      explanation: `Created ${className} with basic CRUD operations`,
      fileName: `${className}.ts`
    };
  }

  private generateTestCode(task: string, context: any): SimpleCodeGeneration {
    const targetFunction = context?.targetFunction || 'processData';
    const code = `/**
 * Tests for ${targetFunction}
 * Generated by AI Agent System - Phase 1
 */
import { ${targetFunction} } from './${targetFunction}';

describe('${targetFunction}', () => {
  it('should process valid input', () => {
    const input = { value: 'test' };
    const result = ${targetFunction}(input);
    
    expect(result.processed).toBe(true);
    expect(result.data).toEqual(input);
    expect(result.timestamp).toBeDefined();
  });

  it('should throw error for invalid input', () => {
    expect(() => ${targetFunction}(null)).toThrow('Input is required');
    expect(() => ${targetFunction}(undefined)).toThrow('Input is required');
  });

  it('should handle string input', () => {
    const result = ${targetFunction}('  test  ');
    expect(result.data).toBe('test');
  });

  it('should handle array input', () => {
    const result = ${targetFunction}([1, null, 2, undefined, 3]);
    expect(result.data).toEqual([1, 2, 3]);
  });
});`;

    return {
      code,
      language: 'typescript',
      explanation: `Created comprehensive tests for ${targetFunction}`,
      fileName: `${targetFunction}.test.ts`
    };
  }

  private generateBugFix(task: string, context: any): SimpleCodeGeneration {
    // Simple bug fix pattern
    const code = `// Bug fix: ${task}
// Analysis: ${context?.analysis || 'Issue identified in error handling'}

// Before fix:
// if (value) { process(value) }

// After fix:
if (value !== null && value !== undefined) {
  try {
    process(value);
  } catch (error) {
    console.error('Processing failed:', error);
    // Graceful fallback
    return defaultValue;
  }
}`;

    return {
      code,
      language: 'typescript',
      explanation: 'Applied defensive programming pattern to fix potential null/undefined issue',
      fileName: 'bugfix.ts'
    };
  }

  private generateGenericCode(task: string, context: any): SimpleCodeGeneration {
    const code = `/**
 * Implementation for: ${task}
 * Generated by AI Agent System - Phase 1
 */

// TODO: Implement based on requirements
export function implement(): void {
  console.log('Implementation placeholder for: ${task}');
  
  // Add your logic here
  const config = ${JSON.stringify(context || {}, null, 2)};
  
  // Process based on configuration
  console.log('Processing with config:', config);
}`;

    return {
      code,
      language: 'typescript',
      explanation: `Generated implementation scaffold for: ${task}`,
      fileName: 'implementation.ts'
    };
  }

  // Phase 1: Simple status reporting
  getStatus(): any {
    return {
      agent: this.name,
      phase: getCurrentConfig().phase,
      capabilities: {
        codeGeneration: true,
        patternRecognition: true,
        multiFileGeneration: false, // Disabled in Phase 1
        refactoring: false, // Disabled in Phase 1
        aiPowered: false // Coming in Phase 2
      }
    };
  }

  /**
   * Estimate token usage for Phase 1 (simulated)
   * In Phase 2, this will use actual AI provider token counts
   */
  private estimateTokenUsage(task: string, implementation: SimpleCodeGeneration): number {
    // Base tokens for task analysis and generation
    let tokens = 800;
    
    // Add tokens based on code complexity
    const linesOfCode = implementation.code.split('\n').length;
    tokens += linesOfCode * 20;
    
    // Add tokens based on task type
    if (task.includes('class') || task.includes('service')) {
      tokens += 1500;
    } else if (task.includes('test')) {
      tokens += 1200;
    } else if (task.includes('function')) {
      tokens += 800;
    }
    
    return tokens;
  }
}